# 005 - Receipts and Events

**Moat: Verified Agent Capabilities Marketplace**
*Receipt schema, OutcomeEvent schema, idempotency rules, and "bill once" guarantee*

---

## Overview

Every execution attempt — successful or failed — produces two immutable records:

1. **Receipt** — the auditable proof that a capability was executed (or attempted). Write-once.
2. **OutcomeEvent** — the telemetry signal consumed by the Trust Plane scorer. Append-only.

These two records are the foundation of Moat's trust, governance, and data moats. Without them, there is no scoring, no audit trail, and no idempotency guarantee.

---

## Receipt Schema

### Pydantic Model

```python
from __future__ import annotations

from enum import Enum
from pydantic import BaseModel, Field


class ExecutionStatus(str, Enum):
    SUCCESS = "success"
    FAILURE = "failure"
    TIMEOUT = "timeout"
    POLICY_DENIED = "policy_denied"
    IDEMPOTENT_HIT = "idempotent_hit"   # No re-execution; cached receipt returned


class Receipt(BaseModel):
    """
    Immutable record of a capability execution attempt.
    Written once; never updated.
    """

    # --- Identity ---
    id: str = Field(
        ...,
        description="UUID v7 (time-ordered). Primary key.",
        examples=["01JTEST000000000000000001"],
    )
    capability_id: str = Field(
        ...,
        description="Capability ID at execution time.",
        examples=["slack.post_message"],
    )
    capability_version: str = Field(
        ...,
        description="Exact semver of the capability manifest used.",
        examples=["1.2.0"],
    )
    adapter_id: str = Field(
        ...,
        description="Adapter that handled execution.",
        examples=["slack-adapter-v2"],
    )

    # --- Tenant and Request Context ---
    tenant_id: str = Field(
        ...,
        description="Tenant that made the request.",
    )
    connection_id: str = Field(
        ...,
        description="Connection (credential reference) used.",
    )
    request_id: str = Field(
        ...,
        description="Inbound request ID. Correlates to gateway access log.",
    )

    # --- Timing ---
    timestamp: str = Field(
        ...,
        description="ISO 8601 UTC timestamp when execution was initiated.",
    )
    latency_ms: int = Field(
        ...,
        description="Wall-clock milliseconds from gateway receipt to response.",
        ge=0,
    )

    # --- Idempotency ---
    idempotency_key: str = Field(
        ...,
        description=(
            "Caller-supplied idempotency key. "
            "Unique within a tenant. "
            "Same key within 24h returns this receipt without re-execution."
        ),
        max_length=256,
    )

    # --- Input/Output (redacted) ---
    input_hash: str = Field(
        ...,
        description=(
            "SHA-256 of the canonicalized (JSON-sorted, secret-stripped) input. "
            "Used for audit and replay detection. Raw input is never stored."
        ),
    )
    output_hash: str | None = Field(
        default=None,
        description=(
            "SHA-256 of the canonicalized output. "
            "None on failure (no output produced)."
        ),
    )

    # --- Outcome ---
    status: ExecutionStatus = Field(
        ...,
        description="Execution outcome.",
    )
    error_code: str | None = Field(
        default=None,
        description=(
            "Normalized error code on failure. "
            "See error taxonomy in 005-receipts-and-events.md. "
            "None on success."
        ),
        examples=["PROVIDER_RATE_LIMITED", "TIMEOUT", "INVALID_INPUT"],
    )
    http_status: int | None = Field(
        default=None,
        description="HTTP status code returned by the provider API. None on policy_denied.",
    )

    # --- Policy ---
    policy_decision_id: str = Field(
        ...,
        description="FK to the PolicyDecision record that authorized this execution.",
    )

    # --- Trust ---
    is_synthetic: bool = Field(
        default=False,
        description="True if generated by the synthetic prober, not a real agent request.",
    )

    class Config:
        use_enum_values = True
```

### Example Receipt (success)

```json
{
  "id": "01JP4X7B3K0000000000000001",
  "capability_id": "slack.post_message",
  "capability_version": "1.2.0",
  "adapter_id": "slack-adapter-v2",
  "tenant_id": "tenant_acme",
  "connection_id": "conn_01J...",
  "request_id": "req_01J...",
  "timestamp": "2026-02-17T14:22:11.004Z",
  "latency_ms": 342,
  "idempotency_key": "agent-run-abc-step-7",
  "input_hash": "sha256:a3f1b2c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2",
  "output_hash": "sha256:b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5",
  "status": "success",
  "error_code": null,
  "http_status": 200,
  "policy_decision_id": "01JP4X7B3K0000000000000000",
  "is_synthetic": false
}
```

### Example Receipt (failure)

```json
{
  "id": "01JP4X7B3K0000000000000002",
  "capability_id": "github.create_issue",
  "capability_version": "2.0.1",
  "adapter_id": "github-rest-v1",
  "tenant_id": "tenant_acme",
  "connection_id": "conn_01J...",
  "request_id": "req_01J...",
  "timestamp": "2026-02-17T14:23:05.112Z",
  "latency_ms": 10042,
  "idempotency_key": "agent-run-abc-step-8",
  "input_hash": "sha256:c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6",
  "output_hash": null,
  "status": "timeout",
  "error_code": "TIMEOUT",
  "http_status": null,
  "policy_decision_id": "01JP4X7B3K0000000000000001",
  "is_synthetic": false
}
```

---

## OutcomeEvent Schema

OutcomeEvents are the raw telemetry signal fed into the Trust Plane scoring pipeline. They are separate from receipts to allow the event store to be optimized for time-series queries (partitioned by month).

### Pydantic Model

```python
from __future__ import annotations

from pydantic import BaseModel, Field


class ErrorTaxonomy(str, Enum):
    """
    Normalized error categories for aggregation in trust scoring.
    Avoids provider-specific error strings polluting aggregate metrics.
    """
    NONE = "none"                     # Success
    PROVIDER_RATE_LIMITED = "provider_rate_limited"
    PROVIDER_AUTH_FAILURE = "provider_auth_failure"
    PROVIDER_SERVER_ERROR = "provider_server_error"
    PROVIDER_NOT_FOUND = "provider_not_found"
    PROVIDER_INVALID_INPUT = "provider_invalid_input"
    TIMEOUT = "timeout"
    NETWORK_ERROR = "network_error"
    GATEWAY_ERROR = "gateway_error"
    POLICY_DENIED = "policy_denied"
    UNKNOWN = "unknown"


class OutcomeEvent(BaseModel):
    """
    Telemetry signal emitted after every execution attempt.
    Consumed by Trust Plane scorer. Append-only.
    Partitioned by month.
    """

    # --- Identity ---
    id: str = Field(..., description="UUID v7. Event ID.")
    receipt_id: str = Field(..., description="FK to Receipt.id.")
    capability_id: str
    capability_version: str
    tenant_id: str

    # --- Outcome ---
    success: bool = Field(
        ...,
        description="True if status=success. False for all other statuses.",
    )
    latency_ms: int = Field(..., ge=0)
    error_taxonomy: ErrorTaxonomy = Field(
        ...,
        description="Normalized error category. Used for aggregate scoring.",
    )
    http_status: int | None = None

    # --- Timing ---
    timestamp: str = Field(..., description="ISO 8601 UTC. Used for partitioning.")

    # --- Metadata ---
    is_synthetic: bool = Field(
        default=False,
        description="True if generated by synthetic prober.",
    )
    adapter_id: str

    class Config:
        use_enum_values = True
```

### Example OutcomeEvent

```json
{
  "id": "01JP4X7B3K0000000000000010",
  "receipt_id": "01JP4X7B3K0000000000000001",
  "capability_id": "slack.post_message",
  "capability_version": "1.2.0",
  "tenant_id": "tenant_acme",
  "success": true,
  "latency_ms": 342,
  "error_taxonomy": "none",
  "http_status": 200,
  "timestamp": "2026-02-17T14:22:11.004Z",
  "is_synthetic": false,
  "adapter_id": "slack-adapter-v2"
}
```

---

## Idempotency Rules

### Purpose

Idempotency prevents agents from causing duplicate side effects when retrying after network failures. The guarantee: **the same idempotency key within 24 hours returns the original receipt without re-executing the capability.**

### Key Properties

| Property | Value |
|----------|-------|
| Scope | Per tenant. Keys are not globally unique. |
| TTL | 24 hours from first execution. |
| Collision behavior | Return cached receipt. No error. No re-execution. |
| Failed execution | Failure receipts are cached too. Same key → same failure receipt. |
| Key format | Caller-supplied string, max 256 chars. Opaque to Moat. |

### Idempotency Key Recommendations (for agents)

Good key patterns:
- `{agent-run-id}-{step-id}` — ties the key to a specific action in a specific run
- `{workflow-id}-{capability}-{sequence}` — human-readable and auditable
- `{date}-{operation}-{hash-of-inputs}` — content-addressed

Bad key patterns:
- Static string (e.g., `"send-slack-message"`) — will collide across runs
- Timestamp alone — clock drift creates collisions
- Random UUID without storing it — defeats the purpose

### Idempotency Implementation

```
1. Gateway receives execute request with idempotency_key.

2. PolicyEnforcer checks:
   SELECT id, status FROM receipts
   WHERE tenant_id = $tenant_id
   AND idempotency_key = $key
   AND timestamp > NOW() - INTERVAL '24 hours'
   LIMIT 1

3a. If row found:
    - Return existing receipt.
    - Set X-Moat-Idempotent-Replayed: true header.
    - Do NOT re-execute. Do NOT increment budget counter.
    - Log PolicyDecision with rule_hit=IDEMPOTENT_HIT.

3b. If no row found:
    - Proceed with policy evaluation (scope, budget, etc.).
    - On execution complete, INSERT receipt with idempotency_key.
    - ON CONFLICT (tenant_id, idempotency_key) DO NOTHING
      (handles race condition between concurrent retries).

4. In race condition (two requests with same key arrive simultaneously):
   - Both pass step 2 (no row yet).
   - Both proceed to execute (database constraint prevents double-insert).
   - First INSERT wins. Second INSERT is a no-op.
   - Second request reads the winning receipt and returns it.
   - At most one side effect occurs.
```

### "Bill Once" Guarantee

The budget counter is **only incremented on successful execution, and only once per unique idempotency key.** This means:

- Failed executions do not consume budget.
- Idempotent hits do not consume additional budget.
- Retries of failed calls consume budget only on each new attempt (new idempotency key or expired TTL).

```
First call (idempotency_key=X) → SUCCESS → budget +1 → receipt stored
Second call (idempotency_key=X, within 24h) → IDEMPOTENT_HIT → budget +0 → cached receipt returned
Third call (idempotency_key=Y) → FAILURE → budget +0 → failure receipt stored
Fourth call (idempotency_key=Y, within 24h) → IDEMPOTENT_HIT → budget +0 → cached failure receipt
```

---

## Error Taxonomy

Normalizing provider-specific errors into a taxonomy enables aggregate trust scoring that is provider-agnostic.

| Taxonomy Code | Provider Examples | Trust Score Impact |
|--------------|------------------|-------------------|
| `none` | HTTP 200 | Positive |
| `provider_rate_limited` | HTTP 429 | Neutral (not provider fault) |
| `provider_auth_failure` | HTTP 401, 403 | High negative (credential issue) |
| `provider_server_error` | HTTP 500, 502, 503 | Negative |
| `provider_not_found` | HTTP 404 | Moderate negative |
| `provider_invalid_input` | HTTP 400, 422 | Low negative (often caller error) |
| `timeout` | Request > timeout threshold | Negative (latency impact) |
| `network_error` | DNS failure, TCP reset | Moderate negative |
| `gateway_error` | Internal Moat error | Excluded from provider score |
| `policy_denied` | Policy check failed | Excluded from provider score |
| `unknown` | Unmapped error | Moderate negative |

**Scoring exclusions:** `gateway_error` and `policy_denied` outcomes are excluded from the capability's trust score because they are not caused by the provider's reliability. The `provider_rate_limited` taxonomy is counted in success_rate with a 0.5 weight (partial credit: the capability responded, but is temporarily unavailable).

---

## Redaction Rules

Raw inputs and outputs are never stored. Before computing hashes and before any logging:

### Secret Key Denylist

The following keys are stripped from request/response bodies before hashing and logging (case-insensitive, partial-match):

```python
REDACTED_KEY_PATTERNS = [
    "authorization",
    "api_key",
    "apikey",
    "api-key",
    "token",
    "password",
    "passwd",
    "secret",
    "credential",
    "credentials",
    "bearer",
    "private_key",
    "privatekey",
    "access_key",
    "accesskey",
    "client_secret",
    "refresh_token",
]
```

Any JSON key that **contains** any of these strings (case-insensitive) has its value replaced with `"[REDACTED]"` before hashing. The hash is computed over the redacted form.

### Redaction Process

```
raw_input = {original request body}
redacted_input = deep_redact(raw_input, REDACTED_KEY_PATTERNS)
input_hash = sha256(json.dumps(redacted_input, sort_keys=True))

# Only input_hash is stored; redacted_input and raw_input are discarded
```

The same process applies to outputs.

**Consequence:** Receipts cannot be used to replay exact inputs. They prove that a call happened with a specific (redacted) input, not what the raw secrets were.
