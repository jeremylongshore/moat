# Moat – Continuous Integration
#
# Triggers:
#   - Push to main  (post-merge gate, protects the default branch)
#   - Pull request targeting main  (pre-merge gate, fast feedback)
#
# Job graph:
#   lint ──┬── test ──┬── security
#          │          └── integration (main only)
#          └── docker (3× parallel: gateway, control-plane, trust-plane)
#   typecheck  (parallel, continue-on-error)
#
# Design decisions:
#   - All jobs install packages in editable mode (-e) so import paths match
#     the repo layout exactly – no surprises between local and CI.
#   - The test job uploads a coverage artefact so it can be inspected on
#     failure without re-running the suite.
#   - pip-audit is a separate job (not part of `test`) so it never blocks
#     the test result when a transitive dep has a fresh advisory.

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

# Cancel in-progress runs for the same branch/PR when a new push arrives.
# This keeps the runner queue clean and gives faster PR feedback.
concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: "3.12"

jobs:

  # ───────────────────────────────────────────────────────────────────────────
  # lint
  # Ruff: check for errors + enforce formatting (no writes).
  # Fail fast – no point running tests on badly formatted code.
  # ───────────────────────────────────────────────────────────────────────────
  lint:
    name: Lint (ruff)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip

      - name: Install ruff
        run: pip install ruff>=0.4.0

      - name: ruff check (lint)
        run: ruff check packages/ services/

      - name: ruff format --check (formatting)
        run: ruff format --check packages/ services/

  # ───────────────────────────────────────────────────────────────────────────
  # typecheck
  # mypy – continue-on-error while we ramp up annotations.
  # Reports results as a non-blocking annotation in the PR UI.
  # ───────────────────────────────────────────────────────────────────────────
  typecheck:
    name: Type Check (mypy)
    runs-on: ubuntu-latest
    # Intentionally does NOT need lint to finish – runs in parallel.
    continue-on-error: true   # Remove once annotation coverage is solid.

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip

      - name: Install all packages (editable) + dev deps
        run: |
          pip install mypy>=1.9.0 pydantic>=2.0.0
          pip install -e packages/core
          pip install -e services/control-plane
          pip install -e services/gateway
          pip install -e services/trust-plane
          pip install -e services/mcp-server

      - name: mypy
        run: mypy packages/ services/ --config-file pyproject.toml

  # ───────────────────────────────────────────────────────────────────────────
  # test
  # Full pytest suite with coverage. Fails the build on any test failure.
  # ───────────────────────────────────────────────────────────────────────────
  test:
    name: Test (pytest + coverage)
    runs-on: ubuntu-latest
    needs: [lint]   # Don't burn runner minutes if lint fails.

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip

      - name: Install dev dependencies
        run: pip install -r requirements-dev.txt

      - name: Install moat-core
        run: pip install -e packages/core

      # Run tests per-service to avoid 'app' package name collisions.
      # Each service uses 'app' as its internal package name, so editable
      # installs overwrite each other. Testing in isolation prevents this.

      - name: Test packages/core
        run: |
          pip install httpx
          cd packages/core
          pytest --tb=short -v \
            --cov=moat_core \
            --cov-report=term-missing \
            --cov-report=xml:../../coverage-core.xml \
            tests/

      - name: Test services/control-plane
        run: |
          pip install -e services/control-plane
          cd services/control-plane
          pytest --tb=short -v tests/

      - name: Test services/gateway
        run: |
          pip install -e services/gateway
          cd services/gateway
          pytest --tb=short -v tests/

      - name: Merge coverage
        if: always()
        run: |
          # Core coverage is the primary metric
          cp coverage-core.xml coverage.xml || true

      - name: Upload coverage report
        if: always()   # Upload even if tests fail – helps diagnose failures.
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.xml
            htmlcov/
          retention-days: 7

  # ───────────────────────────────────────────────────────────────────────────
  # security
  # pip-audit scans all installed packages for known CVEs.
  # Runs after test so it benefits from the warm pip cache, but is a
  # separate job so a new CVE advisory doesn't mask test results.
  # ───────────────────────────────────────────────────────────────────────────
  security:
    name: Security (pip-audit)
    runs-on: ubuntu-latest
    needs: [test]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip

      - name: Install pip-audit + all project packages
        run: |
          pip install pip-audit>=2.7.0
          pip install -r requirements-dev.txt
          pip install -e packages/core
          pip install -e services/control-plane
          pip install -e services/gateway
          pip install -e services/trust-plane
          pip install -e services/mcp-server

      - name: Run pip-audit
        # Output as JSON so it can be parsed by security dashboards.
        # --fix is intentionally omitted – we want to review before upgrading.
        run: pip-audit --format=json --output=pip-audit.json || true

      - name: Display audit results
        if: always()
        run: |
          python3 -c "
          import json, sys
          data = json.load(open('pip-audit.json'))
          vulns = data.get('vulnerabilities', [])
          if not vulns:
              print('No known vulnerabilities found.')
              sys.exit(0)
          print(f'WARNING: {len(vulns)} vulnerability/ies found:')
          for v in vulns:
              print(f'  {v[\"name\"]} {v[\"version\"]}: {v[\"id\"]}')
          # Don't fail CI for now – treat as advisory.
          "

      - name: Upload audit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pip-audit-report
          path: pip-audit.json
          retention-days: 30

  # ───────────────────────────────────────────────────────────────────────────
  # docker
  # Verify all service Dockerfiles build cleanly.
  # Uses BuildKit layer caching via GitHub Actions cache.
  # ───────────────────────────────────────────────────────────────────────────
  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [lint]

    strategy:
      matrix:
        service:
          - { name: gateway, context: ".", dockerfile: services/gateway/Dockerfile }
          - { name: control-plane, context: ".", dockerfile: services/control-plane/Dockerfile }
          - { name: trust-plane, context: ".", dockerfile: services/trust-plane/Dockerfile }

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build ${{ matrix.service.name }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: false
          tags: moat-${{ matrix.service.name }}:ci-${{ github.sha }}
          cache-from: type=gha,scope=${{ matrix.service.name }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service.name }}

  # ───────────────────────────────────────────────────────────────────────────
  # integration
  # Spin up the full Docker Compose stack and run end-to-end tests.
  # Only runs on pushes to main (not on every PR) to conserve minutes.
  # ───────────────────────────────────────────────────────────────────────────
  integration:
    name: Integration Tests (Docker Compose)
    runs-on: ubuntu-latest
    needs: [test, docker]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Copy env file
        run: cp infra/local/.env.example infra/local/.env

      - name: Start Docker Compose stack
        run: |
          docker compose -f infra/local/docker-compose.yml up -d --build --wait --wait-timeout 120
          docker compose -f infra/local/docker-compose.yml ps

      - name: Wait for services
        run: |
          for i in $(seq 1 30); do
            if curl -sf http://localhost:8002/healthz && curl -sf http://localhost:8001/healthz; then
              echo "All services healthy"
              break
            fi
            echo "Waiting for services... ($i/30)"
            sleep 2
          done

      - name: Test gateway health
        run: |
          curl -sf http://localhost:8002/healthz | python3 -m json.tool
          curl -sf http://localhost:8001/healthz | python3 -m json.tool

      - name: Test execute pipeline (stub adapter)
        run: |
          RESPONSE=$(curl -sf -X POST http://localhost:8002/execute/test-cap \
            -H 'Content-Type: application/json' \
            -d '{"tenant_id":"ci-test","params":{"test":true},"scope":"execute"}')
          echo "$RESPONSE" | python3 -m json.tool
          echo "$RESPONSE" | python3 -c "
          import json, sys
          data = json.load(sys.stdin)
          assert 'receipt_id' in data, 'Missing receipt_id'
          assert data.get('tenant_id') == 'ci-test', f'Wrong tenant: {data.get(\"tenant_id\")}'
          print('Execute pipeline: PASS')
          "

      - name: Test policy default-deny (unregistered capability)
        run: |
          HTTP_CODE=$(curl -sf -o /dev/null -w '%{http_code}' -X POST \
            http://localhost:8002/execute/nonexistent-cap \
            -H 'Content-Type: application/json' \
            -d '{"tenant_id":"ci-test","params":{}}')
          if [ "$HTTP_CODE" = "404" ] || [ "$HTTP_CODE" = "403" ]; then
            echo "Default-deny: PASS (HTTP $HTTP_CODE)"
          else
            echo "Default-deny: FAIL (expected 403/404, got $HTTP_CODE)"
            exit 1
          fi

      - name: Collect logs on failure
        if: failure()
        run: docker compose -f infra/local/docker-compose.yml logs > docker-compose-logs.txt

      - name: Upload logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: docker-compose-logs
          path: docker-compose-logs.txt
          retention-days: 7

      - name: Teardown
        if: always()
        run: docker compose -f infra/local/docker-compose.yml down -v
